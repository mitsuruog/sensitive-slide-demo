
<!DOCTYPE html>
<html lang="en">
<head>
	<title>three.js webgl - materials - shaders [Fresnel]</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<style>
		body {
			background:#000;
			padding:0;
			margin:0;
			font-weight: bold;
			overflow:hidden;
		}

		#info {
			position: absolute;
			top: 0px; width: 100%;
			color: #ffffff;
			padding: 5px;
			font-family:Monospace;
			font-size:13px;
			text-align:center;
			z-index:1000;
		}

		a {	color: #ffffff;	}

		#oldie a { color:#0b0 }
	</style>
</head>

<body>

<div id="info">
	<a href="http://threejs.org" target="_blank">three.js</a> - webgl cube Fresnel shader demo. texture by <a href="http://www.humus.name/index.php?page=Textures" target="_blank">Humus</a>
</div>

<script src="js/tree_demo/three.min.js"></script>

<script src="js/tree_demo/FresnelShader.js"></script>

<script src="js/tree_demo/Detector.js"></script>

<script src="/socket.io/socket.io.js"></script>

<script>

	if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

	var container;

	var camera, scene, renderer;
	var cameraCube, sceneCube;

	var mesh, zmesh, lightMesh, geometry;
	var spheres = [];

	var directionalLight, pointLight;

	var mouseX = 0, mouseY = 0;

	var windowHalfX = socketX = window.innerWidth / 2;
	var windowHalfY = socketY = window.innerHeight / 2;

	document.addEventListener( 'mousemove', onDocumentMouseMove, false );

	init();
	animate();

	function init() {

		container = document.createElement( 'div' );
		document.body.appendChild( container );

		camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 1, 100000 );
		camera.position.z = 3200;

		cameraCube = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 1, 100000 );

		scene = new THREE.Scene();
		sceneCube = new THREE.Scene();


		var geometry = new THREE.SphereGeometry( 100, 32, 16 );

		//var path = "textures/cube/Park2/";
		var path = "image/textures/";
		var format = '.jpg';
		var urls = [
			path + 'posx' + format, path + 'negx' + format,
			path + 'posy' + format, path + 'negy' + format,
			path + 'posz' + format, path + 'negz' + format
		];


		var textureCube = THREE.ImageUtils.loadTextureCube( urls );
		textureCube.format = THREE.RGBFormat;

		var shader = THREE.FresnelShader;
		var uniforms = THREE.UniformsUtils.clone( shader.uniforms );

		uniforms[ "tCube" ].value = textureCube;

		var parameters = { fragmentShader: shader.fragmentShader, vertexShader: shader.vertexShader, uniforms: uniforms };
		var material = new THREE.ShaderMaterial( parameters );

		for ( var i = 0; i < 500; i ++ ) {

			var mesh = new THREE.Mesh( geometry, material );

			mesh.position.x = Math.random() * 10000 - 5000;
			mesh.position.y = Math.random() * 10000 - 5000;
			mesh.position.z = Math.random() * 10000 - 5000;

			mesh.scale.x = mesh.scale.y = mesh.scale.z = Math.random() * 3 + 1;

			scene.add( mesh );

			spheres.push( mesh );
     }

		scene.matrixAutoUpdate = false;

		// Skybox

		var shader = THREE.ShaderLib[ "cube" ];
		shader.uniforms[ "tCube" ].value = textureCube;

		var material = new THREE.ShaderMaterial( {

				fragmentShader: shader.fragmentShader,
				vertexShader: shader.vertexShader,
				uniforms: shader.uniforms,
				side: THREE.BackSide

			} ),

			mesh = new THREE.Mesh( new THREE.CubeGeometry( 100000, 100000, 100000 ), material );
		sceneCube.add( mesh );

		//

		renderer = new THREE.WebGLRenderer( { antialias: false } );
		renderer.setSize( window.innerWidth, window.innerHeight );
		renderer.autoClear = false;
		container.appendChild( renderer.domElement );

		//

		window.addEventListener( 'resize', onWindowResize, false );

	}

	function onWindowResize() {

		windowHalfX = window.innerWidth / 2;
		windowHalfY = window.innerHeight / 2;

		camera.aspect = window.innerWidth / window.innerHeight;
		camera.updateProjectionMatrix();

		cameraCube.aspect = window.innerWidth / window.innerHeight;
		cameraCube.updateProjectionMatrix();

		renderer.setSize( window.innerWidth, window.innerHeight );

	}

	function onDocumentMouseMove( event ) {

		mouseX = ( event.clientX - windowHalfX ) * 10;
		mouseY = ( event.clientY - windowHalfY ) * 10;

	}

	//

	function animate() {

		requestAnimationFrame( animate );

		render();

	}

	function render() {

		var timer = 0.0001 * Date.now();

		camera.position.x += ( mouseX - camera.position.x ) * .05;
		camera.position.y += ( - mouseY - camera.position.y ) * .05;

		camera.lookAt( scene.position );

		cameraCube.rotation.copy( camera.rotation );

		for ( var i = 0, il = spheres.length; i < il; i ++ ) {

			var sphere = spheres[ i ];

			sphere.position.x = 5000 * Math.cos( timer + i );
			sphere.position.y = 5000 * Math.sin( timer + i * 1.1 );

		}

		renderer.clear();
		renderer.render( sceneCube, cameraCube );
		renderer.render( scene, camera );

	}

	var screenX = lowPx = window.innerWidth;
	var screenY = lowPy = window.innerHeight;

	var socket = io.connect();
	socket.on('orient data', function (data) {

		socketX = data.g * 30 * 0.9 + socketX * 30 * 0.1;
		socketY = data.a * 30 * 0.9 + socketY * 30 * 0.1;

//		socketX = socketX + Math.round(data.g * 30);
//		socketY = socketY + Math.round(data.a * 30);

//		lowPx = data.g * 30 * 0.9 + socketX * 30 * 0.1;
//		lowPy = data.a * 30 * 0.9 + socketY * 30 * 0.1;
//		socketX = data.g * 30 - lowPx;
//		socketY = data.a * 30 - lowPy;

		if(socketX < 0) socketX = 0;
		if(socketY < 0) socketY = 0;
		if(socketX > screenX) socketX = screenX;
		if(socketY > screenY) socketY = screenY;

		mouseX = (socketX - windowHalfX ) * 7.5;
		mouseY = (socketY - windowHalfY ) * 7.5;

//		mouseX = data.g * 30;
//		mouseY = data.a * 30;

	});

	socket.on('motion', function (data) {

		if (data.init === true) {
			mouseX = windowHalfX;
			mouseY = windowHalfY;
		}

	});

</script>

</body>
</html>
